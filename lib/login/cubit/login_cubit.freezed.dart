// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'login_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$LoginState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() email,
    required TResult Function() phone,
    required TResult Function() codeVerification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? inital,
    TResult? Function()? email,
    TResult? Function()? phone,
    TResult? Function()? codeVerification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? email,
    TResult Function()? phone,
    TResult Function()? codeVerification,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Inital value) inital,
    required TResult Function(Email value) email,
    required TResult Function(Phone value) phone,
    required TResult Function(CodeVerification value) codeVerification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Inital value)? inital,
    TResult? Function(Email value)? email,
    TResult? Function(Phone value)? phone,
    TResult? Function(CodeVerification value)? codeVerification,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Inital value)? inital,
    TResult Function(Email value)? email,
    TResult Function(Phone value)? phone,
    TResult Function(CodeVerification value)? codeVerification,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginStateCopyWith<$Res> {
  factory $LoginStateCopyWith(
          LoginState value, $Res Function(LoginState) then) =
      _$LoginStateCopyWithImpl<$Res, LoginState>;
}

/// @nodoc
class _$LoginStateCopyWithImpl<$Res, $Val extends LoginState>
    implements $LoginStateCopyWith<$Res> {
  _$LoginStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitalImplCopyWith<$Res> {
  factory _$$InitalImplCopyWith(
          _$InitalImpl value, $Res Function(_$InitalImpl) then) =
      __$$InitalImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitalImplCopyWithImpl<$Res>
    extends _$LoginStateCopyWithImpl<$Res, _$InitalImpl>
    implements _$$InitalImplCopyWith<$Res> {
  __$$InitalImplCopyWithImpl(
      _$InitalImpl _value, $Res Function(_$InitalImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitalImpl implements Inital {
  const _$InitalImpl();

  @override
  String toString() {
    return 'LoginState.inital()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitalImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() email,
    required TResult Function() phone,
    required TResult Function() codeVerification,
  }) {
    return inital();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? inital,
    TResult? Function()? email,
    TResult? Function()? phone,
    TResult? Function()? codeVerification,
  }) {
    return inital?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? email,
    TResult Function()? phone,
    TResult Function()? codeVerification,
    required TResult orElse(),
  }) {
    if (inital != null) {
      return inital();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Inital value) inital,
    required TResult Function(Email value) email,
    required TResult Function(Phone value) phone,
    required TResult Function(CodeVerification value) codeVerification,
  }) {
    return inital(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Inital value)? inital,
    TResult? Function(Email value)? email,
    TResult? Function(Phone value)? phone,
    TResult? Function(CodeVerification value)? codeVerification,
  }) {
    return inital?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Inital value)? inital,
    TResult Function(Email value)? email,
    TResult Function(Phone value)? phone,
    TResult Function(CodeVerification value)? codeVerification,
    required TResult orElse(),
  }) {
    if (inital != null) {
      return inital(this);
    }
    return orElse();
  }
}

abstract class Inital implements LoginState {
  const factory Inital() = _$InitalImpl;
}

/// @nodoc
abstract class _$$EmailImplCopyWith<$Res> {
  factory _$$EmailImplCopyWith(
          _$EmailImpl value, $Res Function(_$EmailImpl) then) =
      __$$EmailImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmailImplCopyWithImpl<$Res>
    extends _$LoginStateCopyWithImpl<$Res, _$EmailImpl>
    implements _$$EmailImplCopyWith<$Res> {
  __$$EmailImplCopyWithImpl(
      _$EmailImpl _value, $Res Function(_$EmailImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmailImpl implements Email {
  const _$EmailImpl();

  @override
  String toString() {
    return 'LoginState.email()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmailImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() email,
    required TResult Function() phone,
    required TResult Function() codeVerification,
  }) {
    return email();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? inital,
    TResult? Function()? email,
    TResult? Function()? phone,
    TResult? Function()? codeVerification,
  }) {
    return email?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? email,
    TResult Function()? phone,
    TResult Function()? codeVerification,
    required TResult orElse(),
  }) {
    if (email != null) {
      return email();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Inital value) inital,
    required TResult Function(Email value) email,
    required TResult Function(Phone value) phone,
    required TResult Function(CodeVerification value) codeVerification,
  }) {
    return email(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Inital value)? inital,
    TResult? Function(Email value)? email,
    TResult? Function(Phone value)? phone,
    TResult? Function(CodeVerification value)? codeVerification,
  }) {
    return email?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Inital value)? inital,
    TResult Function(Email value)? email,
    TResult Function(Phone value)? phone,
    TResult Function(CodeVerification value)? codeVerification,
    required TResult orElse(),
  }) {
    if (email != null) {
      return email(this);
    }
    return orElse();
  }
}

abstract class Email implements LoginState {
  const factory Email() = _$EmailImpl;
}

/// @nodoc
abstract class _$$PhoneImplCopyWith<$Res> {
  factory _$$PhoneImplCopyWith(
          _$PhoneImpl value, $Res Function(_$PhoneImpl) then) =
      __$$PhoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PhoneImplCopyWithImpl<$Res>
    extends _$LoginStateCopyWithImpl<$Res, _$PhoneImpl>
    implements _$$PhoneImplCopyWith<$Res> {
  __$$PhoneImplCopyWithImpl(
      _$PhoneImpl _value, $Res Function(_$PhoneImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PhoneImpl implements Phone {
  const _$PhoneImpl();

  @override
  String toString() {
    return 'LoginState.phone()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PhoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() email,
    required TResult Function() phone,
    required TResult Function() codeVerification,
  }) {
    return phone();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? inital,
    TResult? Function()? email,
    TResult? Function()? phone,
    TResult? Function()? codeVerification,
  }) {
    return phone?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? email,
    TResult Function()? phone,
    TResult Function()? codeVerification,
    required TResult orElse(),
  }) {
    if (phone != null) {
      return phone();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Inital value) inital,
    required TResult Function(Email value) email,
    required TResult Function(Phone value) phone,
    required TResult Function(CodeVerification value) codeVerification,
  }) {
    return phone(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Inital value)? inital,
    TResult? Function(Email value)? email,
    TResult? Function(Phone value)? phone,
    TResult? Function(CodeVerification value)? codeVerification,
  }) {
    return phone?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Inital value)? inital,
    TResult Function(Email value)? email,
    TResult Function(Phone value)? phone,
    TResult Function(CodeVerification value)? codeVerification,
    required TResult orElse(),
  }) {
    if (phone != null) {
      return phone(this);
    }
    return orElse();
  }
}

abstract class Phone implements LoginState {
  const factory Phone() = _$PhoneImpl;
}

/// @nodoc
abstract class _$$CodeVerificationImplCopyWith<$Res> {
  factory _$$CodeVerificationImplCopyWith(_$CodeVerificationImpl value,
          $Res Function(_$CodeVerificationImpl) then) =
      __$$CodeVerificationImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CodeVerificationImplCopyWithImpl<$Res>
    extends _$LoginStateCopyWithImpl<$Res, _$CodeVerificationImpl>
    implements _$$CodeVerificationImplCopyWith<$Res> {
  __$$CodeVerificationImplCopyWithImpl(_$CodeVerificationImpl _value,
      $Res Function(_$CodeVerificationImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CodeVerificationImpl implements CodeVerification {
  const _$CodeVerificationImpl();

  @override
  String toString() {
    return 'LoginState.codeVerification()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CodeVerificationImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() email,
    required TResult Function() phone,
    required TResult Function() codeVerification,
  }) {
    return codeVerification();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? inital,
    TResult? Function()? email,
    TResult? Function()? phone,
    TResult? Function()? codeVerification,
  }) {
    return codeVerification?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? email,
    TResult Function()? phone,
    TResult Function()? codeVerification,
    required TResult orElse(),
  }) {
    if (codeVerification != null) {
      return codeVerification();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Inital value) inital,
    required TResult Function(Email value) email,
    required TResult Function(Phone value) phone,
    required TResult Function(CodeVerification value) codeVerification,
  }) {
    return codeVerification(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Inital value)? inital,
    TResult? Function(Email value)? email,
    TResult? Function(Phone value)? phone,
    TResult? Function(CodeVerification value)? codeVerification,
  }) {
    return codeVerification?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Inital value)? inital,
    TResult Function(Email value)? email,
    TResult Function(Phone value)? phone,
    TResult Function(CodeVerification value)? codeVerification,
    required TResult orElse(),
  }) {
    if (codeVerification != null) {
      return codeVerification(this);
    }
    return orElse();
  }
}

abstract class CodeVerification implements LoginState {
  const factory CodeVerification() = _$CodeVerificationImpl;
}
